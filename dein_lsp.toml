[[plugins]]
repo = 'neovim/nvim-lspconfig'

[[plugins]]
repo = 'Shougo/deoplete-lsp'
hook_add = '''
lua << EOF

require'lspconfig'.rust_analyzer.setup({
  settings = {
    ["rust-analyzer"] = {
      assist = {
        importMergeBehaviour = "full",
        importPrefix = "by_crate",
      },

      callInfo = {
        full = true,
      };

      cargo = {
        loadOutDirsFromCheck = true
      },

      checkOnSave = {
        allFeatures = true,
      },

      procMacro = {
        enable = true,
      },
    },
  },
})

require'lspconfig'.tsserver.setup{}

-- define wrapper function for formatting
-- to avoid cursor moving to first line
function formatting_retain_line()
  local line_number = vim.api.nvim_eval("line('.')")
  vim.lsp.buf.formatting_sync()
  vim.api.nvim_command('normal ' .. line_number .. 'G')
end
EOF

" The prefix key.
nnoremap [lsp] <Nop>
nmap     <Space>l      [lsp]

nnoremap [lsp]l <cmd>Commands<CR>^Lsp !Install<Space>
nnoremap [lsp]d <cmd>lua vim.lsp.buf.definition()<CR>
nnoremap [lsp]h <cmd>lua vim.lsp.buf.hover()<CR>
nnoremap [lsp]r <cmd>lua vim.lsp.buf.rename()<CR>
nnoremap [lsp]a <cmd>lua vim.lsp.buf.code_action()<CR>
nnoremap [lsp]f <cmd>lua formatting_retain_line()<CR>
nnoremap [lsp]T <cmd>lua require'lsp_extensions'.inlay_hints()<CR>
nnoremap [lsp]t <cmd>lua require'lsp_extensions'.inlay_hints{ only_current_line = true }<CR>

" Define lsp commands
" Use costum function for "formatting"
command LspFormatting :lua formatting_retain_line()<CR>
lua << EOF
function define_lsp_command(cmd, fun)
  local def_cmd = 'command Lsp' .. cmd .. ' :lua vim.lsp.buf.' .. fun .. '()<CR>'
  vim.api.nvim_command(def_cmd)
end

-- Define command except for "formatting"
define_lsp_command('ClearReference', 'clear_reference')
define_lsp_command('CodeAction', 'code_action')
define_lsp_command('Declaration', 'declaration')
define_lsp_command('Definition', 'definition')
define_lsp_command('DocumentHighlight', 'document_highLight')
define_lsp_command('DocumentSynbol', 'document_synbol')
define_lsp_command('Hover', 'hover')
define_lsp_command('Inplementation', 'inplementation')
define_lsp_command('IncomingCalls', 'incoming_calls')
define_lsp_command('OutgoingCalls', 'outgoing_calls')
define_lsp_command('References', 'references')
define_lsp_command('Rename', 'rename')
define_lsp_command('SignatureHelp', 'signature_help')
define_lsp_command('TypeDefinition', 'type_definition')
define_lsp_command('WorkspaceSymbol', 'workspace_symbol')
EOF

highlight link LspDiagnosticsError ErrorMsg
highlight link LspDiagnosticsVirtualTextError ErrorMsg
highlight link LspDiagnosticsDefaultError ErrorMsg
highlight link LspDiagnosticsWarning Comment
highlight link LspDiagnosticsVirtualTextWarning Comment
highlight link LspDiagnosticsDefaultWarning Comment
highlight link LspDiagnosticsInformation Comment
highlight link LspDiagnosticsVirtualTextInformation Comment
highlight link LspDiagnosticsDefaultInformation Comment
highlight link LspDiagnosticsHint Comment
highlight link LspDiagnosticsVirtualTextHint Comment
highlight link LspDiagnosticsDefaultHint Comment

lua << EOF
-- https://github.com/nvim-lua/diagnostic-nvim/issues/73
vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
  vim.lsp.diagnostic.on_publish_diagnostics, {
    update_in_insert = false,
  }
)
-- quickfix
-- https://github.com/neovim/nvim-lspconfig/issues/69
do
  local method = "textDocument/publishDiagnostics"
  local default_callback = vim.lsp.callbacks[method]
  vim.lsp.callbacks[method] = function(err, method, result, client_id)
    default_callback(err, method, result, client_id)
    if result and result.diagnostics then
      for _, v in ipairs(result.diagnostics) do
        v.bufnr = client_id
        v.lnum = v.range.start.line + 1
        v.col = v.range.start.character + 1
        v.text = v.message
      end
      vim.lsp.util.set_qflist(result.diagnostics)
    end
  end
end

-- a workaround for rust_analyzer
vim.lsp.handlers["textDocument/rename"] = function(_err, _method, result)
    if not result then return end
    if result.documentChanges then
        local merged_changes = {}
        local versions = {}
        for _, change in ipairs(result.documentChanges) do
            if change.kind then
                error("not support")
            else
                local edits = merged_changes[change.textDocument.uri] or {}
                versions[change.textDocument.uri] = change.textDocument.version
                for _, edit in ipairs(change.edits) do
                    table.insert(edits, edit)
                end
                merged_changes[change.textDocument.uri] = edits
            end
        end
        local new_changes = {}
        for uri, edits in pairs(merged_changes) do
            table.insert(new_changes, {
                edits = edits,
                textDocument = {
                    uri = uri,
                    version = versions[uri],
                }})
        end
        result.documentChanges = new_changes
    end

    vim.lsp.util.apply_workspace_edit(result)
end
EOF
'''

[[plugins]]
repo = 'nvim-lua/lsp_extensions.nvim'

[[plugins]]
repo = 'ojroques/nvim-lspfuzzy'
hook_add = '''
lua << EOF
require('lspfuzzy').setup {}
EOF
'''

[[plugins]]
repo = 'nvim-lua/popup.nvim'

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
hook_add = '''
lua << EOF
local actions = require('telescope.actions')
-- Global remapping
------------------------------
require('telescope').setup{
  defaults = {
    mappings = {
      n = {
        ["<esc>"] = actions.close
      },
    },
  }
}
EOF
'''
